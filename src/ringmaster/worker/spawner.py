"""Worker spawner for tmux-based worker management.

Based on docs/09-remaining-decisions.md Section 4:
- On-demand spawning into tmux instances
- Bash script with while loop wrapping headless CLI
- Workers poll for beads via ringmaster CLI
"""

import asyncio
import logging
import shutil
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import Enum
from pathlib import Path

logger = logging.getLogger(__name__)


class SpawnStatus(str, Enum):
    """Status of a spawned worker."""

    STARTING = "starting"
    RUNNING = "running"
    STOPPED = "stopped"
    FAILED = "failed"


@dataclass
class SpawnedWorker:
    """Represents a spawned worker in a tmux session."""

    worker_id: str
    worker_type: str
    tmux_session: str
    worktree_path: str | None
    log_path: str | None
    status: SpawnStatus = SpawnStatus.STARTING
    started_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    pid: int | None = None


class WorkerSpawner:
    """Manages spawning workers in tmux sessions.

    Workers run as bash scripts that:
    1. Poll for available beads via `ringmaster pull-bead`
    2. Build enriched prompts via `ringmaster build-prompt`
    3. Execute the CLI tool (claude, aider, codex, etc.)
    4. Report results via `ringmaster report-result`
    """

    # Default worker script template
    WORKER_SCRIPT_TEMPLATE = '''#!/bin/bash
# Ringmaster worker script for {worker_type}
# Generated by ringmaster worker spawn

set -euo pipefail

WORKER_ID="{worker_id}"
WORKER_TYPE="{worker_type}"
WORKTREE_PATH="{worktree_path}"
LOG_FILE="{log_path}"
CAPABILITIES="{capabilities}"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}}

log "Worker $WORKER_ID ($WORKER_TYPE) starting"
log "Worktree: $WORKTREE_PATH"
log "Capabilities: $CAPABILITIES"

# Main worker loop
ITERATION=0
BACKOFF=1
MAX_BACKOFF=60

while true; do
    # Pull next available bead
    # Build capabilities args
    CAP_ARGS=""
    if [ -n "$CAPABILITIES" ]; then
        for cap in $(echo "$CAPABILITIES" | tr ',' ' '); do
            CAP_ARGS="$CAP_ARGS -c $cap"
        done
    fi

    BEAD_JSON=$(ringmaster pull-bead "$WORKER_ID" $CAP_ARGS --json 2>/dev/null || echo "")

    if [ -z "$BEAD_JSON" ] || [ "$BEAD_JSON" = "null" ]; then
        # No work available, backoff
        sleep $BACKOFF
        BACKOFF=$((BACKOFF * 2))
        if [ $BACKOFF -gt $MAX_BACKOFF ]; then
            BACKOFF=$MAX_BACKOFF
        fi
        continue
    fi

    # Reset backoff on successful pull
    BACKOFF=1

    BEAD_ID=$(echo "$BEAD_JSON" | jq -r '.id')
    BEAD_TITLE=$(echo "$BEAD_JSON" | jq -r '.title // .description' | head -c 50)
    ITERATION=$((ITERATION + 1))

    log "[$ITERATION] Picked up bead $BEAD_ID: $BEAD_TITLE"

    # Change to worktree if specified
    if [ -n "$WORKTREE_PATH" ] && [ -d "$WORKTREE_PATH" ]; then
        cd "$WORKTREE_PATH"
        log "Working in: $WORKTREE_PATH"
    fi

    # Build enriched prompt
    PROMPT_FILE="/tmp/ringmaster-prompt-$BEAD_ID.txt"
    ringmaster build-prompt "$BEAD_ID" -o "$PROMPT_FILE" 2>&1 | tee -a "$LOG_FILE"

    if [ ! -f "$PROMPT_FILE" ]; then
        log "ERROR: Failed to build prompt for $BEAD_ID"
        ringmaster report-result "$BEAD_ID" --status failed --reason "Failed to build prompt" 2>&1 | tee -a "$LOG_FILE"
        continue
    fi

    # Execute worker-specific command
    EXIT_CODE=0
    {worker_command}

    # Report result
    if [ $EXIT_CODE -eq 0 ]; then
        log "[$ITERATION] Completed bead $BEAD_ID successfully"
        ringmaster report-result "$BEAD_ID" --status completed 2>&1 | tee -a "$LOG_FILE"
    else
        log "[$ITERATION] Failed bead $BEAD_ID with exit code $EXIT_CODE"
        ringmaster report-result "$BEAD_ID" --status failed --exit-code $EXIT_CODE 2>&1 | tee -a "$LOG_FILE"
    fi

    # Cleanup prompt file
    rm -f "$PROMPT_FILE"

    log "[$ITERATION] Finished bead $BEAD_ID"
done
'''

    # Worker-specific command templates
    WORKER_COMMANDS = {
        "claude-code": '''
    log "Running Claude Code..."
    claude --print --dangerously-skip-permissions \\
        --model claude-sonnet-4-20250514 \\
        --prompt "$(cat $PROMPT_FILE)" \\
        2>&1 | tee -a "$LOG_FILE" || EXIT_CODE=$?
''',
        "aider": '''
    log "Running Aider..."
    aider --yes --no-git \\
        --model claude-sonnet-4-20250514 \\
        --message "$(cat $PROMPT_FILE)" \\
        2>&1 | tee -a "$LOG_FILE" || EXIT_CODE=$?
''',
        "codex": '''
    log "Running Codex CLI..."
    codex --quiet --auto-approve \\
        "$(cat $PROMPT_FILE)" \\
        2>&1 | tee -a "$LOG_FILE" || EXIT_CODE=$?
''',
        "goose": '''
    log "Running Goose..."
    goose run --non-interactive \\
        --prompt "$(cat $PROMPT_FILE)" \\
        2>&1 | tee -a "$LOG_FILE" || EXIT_CODE=$?
''',
        "generic": '''
    log "Running generic worker..."
    # For custom workers, the command is passed via environment
    if [ -n "$WORKER_COMMAND" ]; then
        eval "$WORKER_COMMAND" 2>&1 | tee -a "$LOG_FILE" || EXIT_CODE=$?
    else
        log "ERROR: No WORKER_COMMAND specified for generic worker"
        EXIT_CODE=1
    fi
''',
    }

    def __init__(
        self,
        log_dir: Path | None = None,
        worktree_dir: Path | None = None,
        db_path: Path | None = None,
        script_dir: Path | None = None,
    ):
        """Initialize the worker spawner.

        Args:
            log_dir: Directory for worker log files.
            worktree_dir: Base directory for worker worktrees.
            db_path: Path to ringmaster database.
            script_dir: Directory to store generated worker scripts.
        """
        self.log_dir = log_dir or Path("/var/log/ringmaster/workers")
        self.worktree_dir = worktree_dir
        self.db_path = db_path or Path(".ringmaster/ringmaster.db")
        self.script_dir = script_dir or Path("/tmp/ringmaster-workers")

        self._spawned_workers: dict[str, SpawnedWorker] = {}

    def _check_tmux_available(self) -> bool:
        """Check if tmux is available on the system."""
        return shutil.which("tmux") is not None

    def _get_tmux_session_name(self, worker_id: str) -> str:
        """Generate tmux session name for a worker."""
        return f"rm-worker-{worker_id}"

    def _generate_worker_script(
        self,
        worker_id: str,
        worker_type: str,
        capabilities: list[str] | None = None,
        worktree_path: str | None = None,
        custom_command: str | None = None,
    ) -> Path:
        """Generate the worker bash script.

        Args:
            worker_id: Unique worker identifier.
            worker_type: Type of worker (claude-code, aider, codex, etc.).
            capabilities: List of worker capabilities.
            worktree_path: Path to git worktree for this worker.
            custom_command: Custom command for generic workers.

        Returns:
            Path to the generated script.
        """
        # Ensure script directory exists
        self.script_dir.mkdir(parents=True, exist_ok=True)

        # Get worker command template
        if worker_type in self.WORKER_COMMANDS:
            worker_command = self.WORKER_COMMANDS[worker_type]
        elif custom_command:
            # For generic workers with custom command
            worker_command = f'''
    log "Running custom command..."
    WORKER_COMMAND="{custom_command}"
    {self.WORKER_COMMANDS["generic"]}
'''
        else:
            worker_command = self.WORKER_COMMANDS["generic"]

        # Format script content
        log_path = self.log_dir / f"{worker_id}.log"
        script_content = self.WORKER_SCRIPT_TEMPLATE.format(
            worker_id=worker_id,
            worker_type=worker_type,
            worktree_path=worktree_path or "",
            log_path=str(log_path),
            capabilities=",".join(capabilities or []),
            worker_command=worker_command,
        )

        # Write script
        script_path = self.script_dir / f"worker-{worker_id}.sh"
        script_path.write_text(script_content)
        script_path.chmod(0o755)

        return script_path

    async def spawn(
        self,
        worker_id: str,
        worker_type: str,
        capabilities: list[str] | None = None,
        worktree_path: str | None = None,
        custom_command: str | None = None,
    ) -> SpawnedWorker:
        """Spawn a worker in a tmux session.

        Args:
            worker_id: Unique worker identifier.
            worker_type: Type of worker (claude-code, aider, codex, etc.).
            capabilities: List of worker capabilities.
            worktree_path: Path to git worktree for this worker.
            custom_command: Custom command for generic workers.

        Returns:
            SpawnedWorker instance.

        Raises:
            RuntimeError: If tmux is not available or spawning fails.
        """
        if not self._check_tmux_available():
            raise RuntimeError("tmux is not available on this system")

        # Check if worker already exists
        if worker_id in self._spawned_workers:
            existing = self._spawned_workers[worker_id]
            if await self.is_running(worker_id):
                logger.warning(f"Worker {worker_id} is already running")
                return existing

        # Generate worker script
        script_path = self._generate_worker_script(
            worker_id=worker_id,
            worker_type=worker_type,
            capabilities=capabilities,
            worktree_path=worktree_path,
            custom_command=custom_command,
        )

        # Create tmux session
        session_name = self._get_tmux_session_name(worker_id)
        log_path = self.log_dir / f"{worker_id}.log"

        # Ensure log directory exists
        self.log_dir.mkdir(parents=True, exist_ok=True)

        # Spawn in tmux
        proc = await asyncio.create_subprocess_exec(
            "tmux",
            "new-session",
            "-d",
            "-s",
            session_name,
            str(script_path),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        _, stderr = await proc.communicate()

        if proc.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            raise RuntimeError(f"Failed to spawn worker {worker_id}: {error_msg}")

        # Create worker record
        worker = SpawnedWorker(
            worker_id=worker_id,
            worker_type=worker_type,
            tmux_session=session_name,
            worktree_path=worktree_path,
            log_path=str(log_path),
            status=SpawnStatus.RUNNING,
        )

        self._spawned_workers[worker_id] = worker
        logger.info(f"Spawned worker {worker_id} in tmux session {session_name}")

        return worker

    async def is_running(self, worker_id: str) -> bool:
        """Check if a worker's tmux session is running.

        Args:
            worker_id: Worker identifier.

        Returns:
            True if the worker is running.
        """
        session_name = self._get_tmux_session_name(worker_id)

        proc = await asyncio.create_subprocess_exec(
            "tmux",
            "has-session",
            "-t",
            session_name,
            stdout=asyncio.subprocess.DEVNULL,
            stderr=asyncio.subprocess.DEVNULL,
        )
        await proc.wait()

        return proc.returncode == 0

    async def kill(self, worker_id: str) -> bool:
        """Kill a worker's tmux session.

        Args:
            worker_id: Worker identifier.

        Returns:
            True if the worker was killed.
        """
        session_name = self._get_tmux_session_name(worker_id)

        proc = await asyncio.create_subprocess_exec(
            "tmux",
            "kill-session",
            "-t",
            session_name,
            stdout=asyncio.subprocess.DEVNULL,
            stderr=asyncio.subprocess.DEVNULL,
        )
        await proc.wait()

        if worker_id in self._spawned_workers:
            self._spawned_workers[worker_id].status = SpawnStatus.STOPPED
            del self._spawned_workers[worker_id]

        logger.info(f"Killed worker {worker_id}")
        return proc.returncode == 0

    async def list_sessions(self) -> list[str]:
        """List all ringmaster worker tmux sessions.

        Returns:
            List of session names.
        """
        proc = await asyncio.create_subprocess_exec(
            "tmux",
            "list-sessions",
            "-F",
            "#{session_name}",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )

        stdout, _ = await proc.communicate()

        if proc.returncode != 0:
            return []

        sessions = stdout.decode().strip().split("\n")
        return [s for s in sessions if s.startswith("rm-worker-")]

    async def get_worker_info(self, worker_id: str) -> SpawnedWorker | None:
        """Get information about a spawned worker.

        Args:
            worker_id: Worker identifier.

        Returns:
            SpawnedWorker instance or None if not found.
        """
        if worker_id in self._spawned_workers:
            worker = self._spawned_workers[worker_id]
            # Update status
            if await self.is_running(worker_id):
                worker.status = SpawnStatus.RUNNING
            else:
                worker.status = SpawnStatus.STOPPED
            return worker
        return None

    async def get_output(
        self, worker_id: str, lines: int = 100
    ) -> str | None:
        """Get recent output from a worker's log file.

        Args:
            worker_id: Worker identifier.
            lines: Number of lines to retrieve.

        Returns:
            Log output or None if not available.
        """
        log_path = self.log_dir / f"{worker_id}.log"

        if not log_path.exists():
            return None

        proc = await asyncio.create_subprocess_exec(
            "tail",
            "-n",
            str(lines),
            str(log_path),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )

        stdout, _ = await proc.communicate()

        if proc.returncode == 0:
            return stdout.decode()
        return None

    def attach_command(self, worker_id: str) -> str:
        """Get the command to attach to a worker's tmux session.

        Args:
            worker_id: Worker identifier.

        Returns:
            Command string to attach to the session.
        """
        session_name = self._get_tmux_session_name(worker_id)
        return f"tmux attach-session -t {session_name}"

    async def send_signal(self, worker_id: str, signal: str = "SIGINT") -> bool:
        """Send a signal to a worker.

        Args:
            worker_id: Worker identifier.
            signal: Signal name (e.g., SIGINT, SIGTERM).

        Returns:
            True if signal was sent.
        """
        session_name = self._get_tmux_session_name(worker_id)

        # Get the pane PID
        proc = await asyncio.create_subprocess_exec(
            "tmux",
            "list-panes",
            "-t",
            session_name,
            "-F",
            "#{pane_pid}",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )

        stdout, _ = await proc.communicate()

        if proc.returncode != 0 or not stdout:
            return False

        pane_pid = stdout.decode().strip().split("\n")[0]

        # Send signal to the process
        kill_proc = await asyncio.create_subprocess_exec(
            "kill",
            f"-{signal}",
            pane_pid,
            stdout=asyncio.subprocess.DEVNULL,
            stderr=asyncio.subprocess.DEVNULL,
        )
        await kill_proc.wait()

        return kill_proc.returncode == 0

    async def cleanup_stale(self) -> list[str]:
        """Clean up stale worker sessions and scripts.

        Returns:
            List of cleaned up worker IDs.
        """
        cleaned = []

        # Find sessions that are no longer running
        for worker_id in list(self._spawned_workers.keys()):
            if not await self.is_running(worker_id):
                del self._spawned_workers[worker_id]
                cleaned.append(worker_id)

        # Clean up old script files
        if self.script_dir.exists():
            for script in self.script_dir.glob("worker-*.sh"):
                # Extract worker ID from script name
                wid = script.stem.replace("worker-", "")
                if not await self.is_running(wid):
                    script.unlink()

        return cleaned
